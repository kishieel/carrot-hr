{"ast":null,"code":"/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['moment'], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but only CommonJS-like\n    // enviroments that support module.exports, like Node.\n    try {\n      module.exports = factory(require('moment'));\n    } catch (e) {\n      // If moment is not available, leave the setup up to the user.\n      // Like when using moment-timezone or similar moment-based package.\n      module.exports = factory;\n    }\n  }\n\n  if (root) {\n    // Globals.\n    root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n  }\n})(this, function (moment) {\n  // `Number#tolocaleString` is tested on plugin initialization.\n  // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n  // native function will be used to generate formatted output. If the feature\n  // test fails, the fallback format function internal to this plugin will be\n  // used.\n  var toLocaleStringWorks = false; // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n  // environments (Edge, IE11, Windows Phone) and possibly other environments.\n  // If the rounding test fails and `toLocaleString` will be used for formatting,\n  // the plugin will \"pre-round\" number values using the fallback number format\n  // function before passing them to `toLocaleString` for final formatting.\n\n  var toLocaleStringRoundingWorks = false; // `Intl.NumberFormat#format` is tested on plugin initialization.\n  // If the feature test passes, `intlNumberFormatRoundingWorks` will be set to\n  // `true` and the native function will be used to generate formatted output.\n  // If the feature test fails, either `Number#tolocaleString` (if\n  // `toLocaleStringWorks` is `true`), or the fallback format function internal\n  //  to this plugin will be used.\n\n  var intlNumberFormatWorks = false; // `Intl.NumberFormat#format` rounds incorrectly for select numbers in Microsoft\n  // environments (Edge, IE11, Windows Phone) and possibly other environments.\n  // If the rounding test fails and `Intl.NumberFormat#format` will be used for\n  // formatting, the plugin will \"pre-round\" number values using the fallback number\n  // format function before passing them to `Intl.NumberFormat#format` for final\n  // formatting.\n\n  var intlNumberFormatRoundingWorks = false; // Token type names in order of descending magnitude.\n\n  var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n  var bubbles = [{\n    type: \"seconds\",\n    targets: [{\n      type: \"minutes\",\n      value: 60\n    }, {\n      type: \"hours\",\n      value: 3600\n    }, {\n      type: \"days\",\n      value: 86400\n    }, {\n      type: \"weeks\",\n      value: 604800\n    }, {\n      type: \"months\",\n      value: 2678400\n    }, {\n      type: \"years\",\n      value: 31536000\n    }]\n  }, {\n    type: \"minutes\",\n    targets: [{\n      type: \"hours\",\n      value: 60\n    }, {\n      type: \"days\",\n      value: 1440\n    }, {\n      type: \"weeks\",\n      value: 10080\n    }, {\n      type: \"months\",\n      value: 44640\n    }, {\n      type: \"years\",\n      value: 525600\n    }]\n  }, {\n    type: \"hours\",\n    targets: [{\n      type: \"days\",\n      value: 24\n    }, {\n      type: \"weeks\",\n      value: 168\n    }, {\n      type: \"months\",\n      value: 744\n    }, {\n      type: \"years\",\n      value: 8760\n    }]\n  }, {\n    type: \"days\",\n    targets: [{\n      type: \"weeks\",\n      value: 7\n    }, {\n      type: \"months\",\n      value: 31\n    }, {\n      type: \"years\",\n      value: 365\n    }]\n  }, {\n    type: \"months\",\n    targets: [{\n      type: \"years\",\n      value: 12\n    }]\n  }]; // stringIncludes\n\n  function stringIncludes(str, search) {\n    if (search.length > str.length) {\n      return false;\n    }\n\n    return str.indexOf(search) !== -1;\n  } // repeatZero(qty)\n  // Returns \"0\" repeated `qty` times.\n  // `qty` must be a integer >= 0.\n\n\n  function repeatZero(qty) {\n    var result = \"\";\n\n    while (qty) {\n      result += \"0\";\n      qty -= 1;\n    }\n\n    return result;\n  }\n\n  function stringRound(digits) {\n    var digitsArray = digits.split(\"\").reverse();\n    var i = 0;\n    var carry = true;\n\n    while (carry && i < digitsArray.length) {\n      if (i) {\n        if (digitsArray[i] === \"9\") {\n          digitsArray[i] = \"0\";\n        } else {\n          digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n          carry = false;\n        }\n      } else {\n        if (parseInt(digitsArray[i], 10) < 5) {\n          carry = false;\n        }\n\n        digitsArray[i] = \"0\";\n      }\n\n      i += 1;\n    }\n\n    if (carry) {\n      digitsArray.push(\"1\");\n    }\n\n    return digitsArray.reverse().join(\"\");\n  } // cachedNumberFormat\n  // Returns an `Intl.NumberFormat` instance for the given locale and configuration.\n  // On first use of a particular configuration, the instance is cached for fast\n  // repeat access.\n\n\n  function cachedNumberFormat(locale, options) {\n    // Create a sorted, stringified version of `options`\n    // for use as part of the cache key\n    var optionsString = map(keys(options).sort(), function (key) {\n      return key + ':' + options[key];\n    }).join(','); // Set our cache key\n\n    var cacheKey = locale + '+' + optionsString; // If we don't have this configuration cached, configure and cache it\n\n    if (!cachedNumberFormat.cache[cacheKey]) {\n      cachedNumberFormat.cache[cacheKey] = Intl.NumberFormat(locale, options);\n    } // Return the cached version of this configuration\n\n\n    return cachedNumberFormat.cache[cacheKey];\n  }\n\n  cachedNumberFormat.cache = {}; // formatNumber\n  // Formats any number greater than or equal to zero using these options:\n  // - userLocale\n  // - useToLocaleString\n  // - useGrouping\n  // - grouping\n  // - maximumSignificantDigits\n  // - minimumIntegerDigits\n  // - fractionDigits\n  // - groupingSeparator\n  // - decimalSeparator\n  //\n  // `useToLocaleString` will use `Intl.NumberFormat` or `toLocaleString` for formatting.\n  // `userLocale` option is passed through to the formatting function.\n  // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n  // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n\n  function formatNumber(number, options, userLocale) {\n    var useToLocaleString = options.useToLocaleString;\n    var useGrouping = options.useGrouping;\n    var grouping = useGrouping && options.grouping.slice();\n    var maximumSignificantDigits = options.maximumSignificantDigits;\n    var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n    var fractionDigits = options.fractionDigits || 0;\n    var groupingSeparator = options.groupingSeparator;\n    var decimalSeparator = options.decimalSeparator;\n\n    if (useToLocaleString && userLocale) {\n      var localeStringOptions = {\n        minimumIntegerDigits: minimumIntegerDigits,\n        useGrouping: useGrouping\n      };\n\n      if (fractionDigits) {\n        localeStringOptions.maximumFractionDigits = fractionDigits;\n        localeStringOptions.minimumFractionDigits = fractionDigits;\n      } // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n      // when maximumSignificantDigits is set. See #96.\n\n\n      if (maximumSignificantDigits && number > 0) {\n        localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n      }\n\n      if (intlNumberFormatWorks) {\n        if (!intlNumberFormatRoundingWorks) {\n          var roundingOptions = extend({}, options);\n          roundingOptions.useGrouping = false;\n          roundingOptions.decimalSeparator = \".\";\n          number = parseFloat(formatNumber(number, roundingOptions), 10);\n        }\n\n        return cachedNumberFormat(userLocale, localeStringOptions).format(number);\n      } else {\n        if (!toLocaleStringRoundingWorks) {\n          var roundingOptions = extend({}, options);\n          roundingOptions.useGrouping = false;\n          roundingOptions.decimalSeparator = \".\";\n          number = parseFloat(formatNumber(number, roundingOptions), 10);\n        }\n\n        return number.toLocaleString(userLocale, localeStringOptions);\n      }\n    }\n\n    var numberString; // Add 1 to digit output length for floating point errors workaround. See below.\n\n    if (maximumSignificantDigits) {\n      numberString = number.toPrecision(maximumSignificantDigits + 1);\n    } else {\n      numberString = number.toFixed(fractionDigits + 1);\n    }\n\n    var integerString;\n    var fractionString;\n    var exponentString;\n    var temp = numberString.split(\"e\");\n    exponentString = temp[1] || \"\";\n    temp = temp[0].split(\".\");\n    fractionString = temp[1] || \"\";\n    integerString = temp[0] || \"\"; // Workaround for floating point errors in `toFixed` and `toPrecision`.\n    // (3.55).toFixed(1); --> \"3.5\"\n    // (123.55 - 120).toPrecision(2); --> \"3.5\"\n    // (123.55 - 120); --> 3.549999999999997\n    // (123.55 - 120).toFixed(2); --> \"3.55\"\n    // Round by examing the string output of the next digit.\n    // *************** Implement String Rounding here ***********************\n    // Check integerString + fractionString length of toPrecision before rounding.\n    // Check length of fractionString from toFixed output before rounding.\n\n    var integerLength = integerString.length;\n    var fractionLength = fractionString.length;\n    var digitCount = integerLength + fractionLength;\n    var digits = integerString + fractionString;\n\n    if (maximumSignificantDigits && digitCount === maximumSignificantDigits + 1 || !maximumSignificantDigits && fractionLength === fractionDigits + 1) {\n      // Round digits.\n      digits = stringRound(digits);\n\n      if (digits.length === digitCount + 1) {\n        integerLength = integerLength + 1;\n      } // Discard final fractionDigit.\n\n\n      if (fractionLength) {\n        digits = digits.slice(0, -1);\n      } // Separate integer and fraction.\n\n\n      integerString = digits.slice(0, integerLength);\n      fractionString = digits.slice(integerLength);\n    } // Trim trailing zeroes from fractionString because toPrecision outputs\n    // precision, not significant digits.\n\n\n    if (maximumSignificantDigits) {\n      fractionString = fractionString.replace(/0*$/, \"\");\n    } // Handle exponent.\n\n\n    var exponent = parseInt(exponentString, 10);\n\n    if (exponent > 0) {\n      if (fractionString.length <= exponent) {\n        fractionString = fractionString + repeatZero(exponent - fractionString.length);\n        integerString = integerString + fractionString;\n        fractionString = \"\";\n      } else {\n        integerString = integerString + fractionString.slice(0, exponent);\n        fractionString = fractionString.slice(exponent);\n      }\n    } else if (exponent < 0) {\n      fractionString = repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString;\n      integerString = \"0\";\n    }\n\n    if (!maximumSignificantDigits) {\n      // Trim or pad fraction when not using maximumSignificantDigits.\n      fractionString = fractionString.slice(0, fractionDigits);\n\n      if (fractionString.length < fractionDigits) {\n        fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n      } // Pad integer when using minimumIntegerDigits\n      // and not using maximumSignificantDigits.\n\n\n      if (integerString.length < minimumIntegerDigits) {\n        integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n      }\n    }\n\n    var formattedString = \"\"; // Handle grouping.\n\n    if (useGrouping) {\n      temp = integerString;\n      var group;\n\n      while (temp.length) {\n        if (grouping.length) {\n          group = grouping.shift();\n        }\n\n        if (formattedString) {\n          formattedString = groupingSeparator + formattedString;\n        }\n\n        formattedString = temp.slice(-group) + formattedString;\n        temp = temp.slice(0, -group);\n      }\n    } else {\n      formattedString = integerString;\n    } // Add decimalSeparator and fraction.\n\n\n    if (fractionString) {\n      formattedString = formattedString + decimalSeparator + fractionString;\n    }\n\n    return formattedString;\n  } // durationLabelCompare\n\n\n  function durationLabelCompare(a, b) {\n    if (a.label.length > b.label.length) {\n      return -1;\n    }\n\n    if (a.label.length < b.label.length) {\n      return 1;\n    } // a must be equal to b\n\n\n    return 0;\n  } // durationGetLabels\n\n\n  function durationGetLabels(token, localeData) {\n    var labels = [];\n    each(keys(localeData), function (localeDataKey) {\n      if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n        return;\n      }\n\n      var labelType = localeDataKey.slice(15).toLowerCase();\n      each(keys(localeData[localeDataKey]), function (labelKey) {\n        if (labelKey.slice(0, 1) === token) {\n          labels.push({\n            type: labelType,\n            key: labelKey,\n            label: localeData[localeDataKey][labelKey]\n          });\n        }\n      });\n    });\n    return labels;\n  } // durationPluralKey\n\n\n  function durationPluralKey(token, integerValue, decimalValue) {\n    // Singular for a value of `1`, but not for `1.0`.\n    if (integerValue === 1 && decimalValue === null) {\n      return token;\n    }\n\n    return token + token;\n  }\n\n  var engLocale = {\n    durationLabelsStandard: {\n      S: 'millisecond',\n      SS: 'milliseconds',\n      s: 'second',\n      ss: 'seconds',\n      m: 'minute',\n      mm: 'minutes',\n      h: 'hour',\n      hh: 'hours',\n      d: 'day',\n      dd: 'days',\n      w: 'week',\n      ww: 'weeks',\n      M: 'month',\n      MM: 'months',\n      y: 'year',\n      yy: 'years'\n    },\n    durationLabelsShort: {\n      S: 'msec',\n      SS: 'msecs',\n      s: 'sec',\n      ss: 'secs',\n      m: 'min',\n      mm: 'mins',\n      h: 'hr',\n      hh: 'hrs',\n      d: 'dy',\n      dd: 'dys',\n      w: 'wk',\n      ww: 'wks',\n      M: 'mo',\n      MM: 'mos',\n      y: 'yr',\n      yy: 'yrs'\n    },\n    durationTimeTemplates: {\n      HMS: 'h:mm:ss',\n      HM: 'h:mm',\n      MS: 'm:ss'\n    },\n    durationLabelTypes: [{\n      type: \"standard\",\n      string: \"__\"\n    }, {\n      type: \"short\",\n      string: \"_\"\n    }],\n    durationPluralKey: durationPluralKey\n  }; // isArray\n\n  function isArray(array) {\n    return Object.prototype.toString.call(array) === \"[object Array]\";\n  } // isObject\n\n\n  function isObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  } // findLast\n\n\n  function findLast(array, callback) {\n    var index = array.length;\n\n    while (index -= 1) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n    }\n  } // find\n\n\n  function find(array, callback) {\n    var index = 0;\n    var max = array && array.length || 0;\n    var match;\n\n    if (typeof callback !== \"function\") {\n      match = callback;\n\n      callback = function (item) {\n        return item === match;\n      };\n    }\n\n    while (index < max) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n\n      index += 1;\n    }\n  } // each\n\n\n  function each(array, callback) {\n    var index = 0,\n        max = array.length;\n\n    if (!array || !max) {\n      return;\n    }\n\n    while (index < max) {\n      if (callback(array[index], index) === false) {\n        return;\n      }\n\n      index += 1;\n    }\n  } // map\n\n\n  function map(array, callback) {\n    var index = 0,\n        max = array.length,\n        ret = [];\n\n    if (!array || !max) {\n      return ret;\n    }\n\n    while (index < max) {\n      ret[index] = callback(array[index], index);\n      index += 1;\n    }\n\n    return ret;\n  } // pluck\n\n\n  function pluck(array, prop) {\n    return map(array, function (item) {\n      return item[prop];\n    });\n  } // compact\n\n\n  function compact(array) {\n    var ret = [];\n    each(array, function (item) {\n      if (item) {\n        ret.push(item);\n      }\n    });\n    return ret;\n  } // unique\n\n\n  function unique(array) {\n    var ret = [];\n    each(array, function (_a) {\n      if (!find(ret, _a)) {\n        ret.push(_a);\n      }\n    });\n    return ret;\n  } // intersection\n\n\n  function intersection(a, b) {\n    var ret = [];\n    each(a, function (_a) {\n      each(b, function (_b) {\n        if (_a === _b) {\n          ret.push(_a);\n        }\n      });\n    });\n    return unique(ret);\n  } // rest\n\n\n  function rest(array, callback) {\n    var ret = [];\n    each(array, function (item, index) {\n      if (!callback(item)) {\n        ret = array.slice(index);\n        return false;\n      }\n    });\n    return ret;\n  } // initial\n\n\n  function initial(array, callback) {\n    var reversed = array.slice().reverse();\n    return rest(reversed, callback).reverse();\n  } // extend\n\n\n  function extend(a, b) {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n\n    return a;\n  } // keys\n\n\n  function keys(a) {\n    var ret = [];\n\n    for (var key in a) {\n      if (a.hasOwnProperty(key)) {\n        ret.push(key);\n      }\n    }\n\n    return ret;\n  } // any\n\n\n  function any(array, callback) {\n    var index = 0,\n        max = array.length;\n\n    if (!array || !max) {\n      return false;\n    }\n\n    while (index < max) {\n      if (callback(array[index], index) === true) {\n        return true;\n      }\n\n      index += 1;\n    }\n\n    return false;\n  } // flatten\n\n\n  function flatten(array) {\n    var ret = [];\n    each(array, function (child) {\n      ret = ret.concat(child);\n    });\n    return ret;\n  }\n\n  function toLocaleStringSupportsLocales() {\n    var number = 0;\n\n    try {\n      number.toLocaleString('i');\n    } catch (e) {\n      return e.name === 'RangeError';\n    }\n\n    return false;\n  }\n\n  function featureTestFormatterRounding(formatter) {\n    return formatter(3.55, \"en\", {\n      useGrouping: false,\n      minimumIntegerDigits: 1,\n      minimumFractionDigits: 1,\n      maximumFractionDigits: 1\n    }) === \"3.6\";\n  }\n\n  function featureTestFormatter(formatter) {\n    var passed = true; // Test minimumIntegerDigits.\n\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 1\n    }) === \"1\";\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 2\n    }) === \"01\";\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 3\n    }) === \"001\";\n\n    if (!passed) {\n      return false;\n    } // Test maximumFractionDigits and minimumFractionDigits.\n\n\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 0,\n      minimumFractionDigits: 0\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 1,\n      minimumFractionDigits: 1\n    }) === \"100.0\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 2,\n      minimumFractionDigits: 2\n    }) === \"99.99\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 3,\n      minimumFractionDigits: 3\n    }) === \"99.990\";\n\n    if (!passed) {\n      return false;\n    } // Test maximumSignificantDigits.\n\n\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 1\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 2\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 3\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 4\n    }) === \"99.99\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 5\n    }) === \"99.99\";\n\n    if (!passed) {\n      return false;\n    } // Test grouping.\n\n\n    passed = passed && formatter(1000, \"en\", {\n      useGrouping: true\n    }) === \"1,000\";\n    passed = passed && formatter(1000, \"en\", {\n      useGrouping: false\n    }) === \"1000\";\n\n    if (!passed) {\n      return false;\n    }\n\n    return true;\n  } // durationsFormat(durations [, template] [, precision] [, settings])\n\n\n  function durationsFormat() {\n    var args = [].slice.call(arguments);\n    var settings = {};\n    var durations; // Parse arguments.\n\n    each(args, function (arg, index) {\n      if (!index) {\n        if (!isArray(arg)) {\n          throw \"Expected array as the first argument to durationsFormat.\";\n        }\n\n        durations = arg;\n      }\n\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n\n    if (!durations || !durations.length) {\n      return [];\n    }\n\n    settings.returnMomentTypes = true;\n    var formattedDurations = map(durations, function (dur) {\n      return dur.format(settings);\n    }); // Merge token types from all durations.\n\n    var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n    var largest = settings.largest;\n\n    if (largest) {\n      outputTypes = outputTypes.slice(0, largest);\n    }\n\n    settings.returnMomentTypes = false;\n    settings.outputTypes = outputTypes;\n    return map(durations, function (dur) {\n      return dur.format(settings);\n    });\n  } // durationFormat([template] [, precision] [, settings])\n\n\n  function durationFormat() {\n    var args = [].slice.call(arguments);\n    var settings = extend({}, this.format.defaults); // Keep a shadow copy of this moment for calculating remainders.\n    // Perform all calculations on positive duration value, handle negative\n    // sign at the very end.\n\n    var asMilliseconds = this.asMilliseconds();\n    var asMonths = this.asMonths(); // Treat invalid durations as having a value of 0 milliseconds.\n\n    if (typeof this.isValid === \"function\" && this.isValid() === false) {\n      asMilliseconds = 0;\n      asMonths = 0;\n    }\n\n    var isNegative = asMilliseconds < 0; // Two shadow copies are needed because of the way moment.js handles\n    // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n\n    var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n    var remainderMonths = moment.duration(Math.abs(asMonths), \"months\"); // Parse arguments.\n\n    each(args, function (arg) {\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n    var momentTokens = {\n      years: \"y\",\n      months: \"M\",\n      weeks: \"w\",\n      days: \"d\",\n      hours: \"h\",\n      minutes: \"m\",\n      seconds: \"s\",\n      milliseconds: \"S\"\n    };\n    var tokenDefs = {\n      escape: /\\[(.+?)\\]/,\n      years: /\\*?[Yy]+/,\n      months: /\\*?M+/,\n      weeks: /\\*?[Ww]+/,\n      days: /\\*?[Dd]+/,\n      hours: /\\*?[Hh]+/,\n      minutes: /\\*?m+/,\n      seconds: /\\*?s+/,\n      milliseconds: /\\*?S+/,\n      general: /.+?/\n    }; // Types array is available in the template function.\n\n    settings.types = types;\n\n    var typeMap = function (token) {\n      return find(types, function (type) {\n        return tokenDefs[type].test(token);\n      });\n    };\n\n    var tokenizer = new RegExp(map(types, function (type) {\n      return tokenDefs[type].source;\n    }).join(\"|\"), \"g\"); // Current duration object is available in the template function.\n\n    settings.duration = this; // Eval template function and cache template string.\n\n    var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template; // outputTypes and returnMomentTypes are settings to support durationsFormat().\n    // outputTypes is an array of moment token types that determines\n    // the tokens returned in formatted output. This option overrides\n    // trim, largest, stopTrim, etc.\n\n    var outputTypes = settings.outputTypes; // returnMomentTypes is a boolean that sets durationFormat to return\n    // the processed momentTypes instead of formatted output.\n\n    var returnMomentTypes = settings.returnMomentTypes;\n    var largest = settings.largest; // Setup stopTrim array of token types.\n\n    var stopTrim = [];\n\n    if (!outputTypes) {\n      if (isArray(settings.stopTrim)) {\n        settings.stopTrim = settings.stopTrim.join(\"\");\n      } // Parse stopTrim string to create token types array.\n\n\n      if (settings.stopTrim) {\n        each(settings.stopTrim.match(tokenizer), function (token) {\n          var type = typeMap(token);\n\n          if (type === \"escape\" || type === \"general\") {\n            return;\n          }\n\n          stopTrim.push(type);\n        });\n      }\n    } // Cache moment's locale data.\n\n\n    var localeData = moment.localeData();\n\n    if (!localeData) {\n      localeData = {};\n    } // Fall back to this plugin's `eng` extension.\n\n\n    each(keys(engLocale), function (key) {\n      if (typeof engLocale[key] === \"function\") {\n        if (!localeData[key]) {\n          localeData[key] = engLocale[key];\n        }\n\n        return;\n      }\n\n      if (!localeData[\"_\" + key]) {\n        localeData[\"_\" + key] = engLocale[key];\n      }\n    }); // Replace Duration Time Template strings.\n    // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n\n    each(keys(localeData._durationTimeTemplates), function (item) {\n      template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n    }); // Determine user's locale.\n\n    var userLocale = settings.userLocale || moment.locale();\n    var useLeftUnits = settings.useLeftUnits;\n    var usePlural = settings.usePlural;\n    var precision = settings.precision;\n    var forceLength = settings.forceLength;\n    var useGrouping = settings.useGrouping;\n    var trunc = settings.trunc; // Use significant digits only when precision is greater than 0.\n\n    var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n    var significantDigits = useSignificantDigits ? settings.precision : 0;\n    var significantDigitsCache = significantDigits;\n    var minValue = settings.minValue;\n    var isMinValue = false;\n    var maxValue = settings.maxValue;\n    var isMaxValue = false; // formatNumber fallback options.\n\n    var useToLocaleString = settings.useToLocaleString;\n    var groupingSeparator = settings.groupingSeparator;\n    var decimalSeparator = settings.decimalSeparator;\n    var grouping = settings.grouping;\n    useToLocaleString = useToLocaleString && (toLocaleStringWorks || intlNumberFormatWorks); // Trim options.\n\n    var trim = settings.trim;\n\n    if (isArray(trim)) {\n      trim = trim.join(\" \");\n    }\n\n    if (trim === null && (largest || maxValue || useSignificantDigits)) {\n      trim = \"all\";\n    }\n\n    if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n      trim = \"large\";\n    }\n\n    if (trim === false) {\n      trim = \"\";\n    }\n\n    var trimIncludes = function (item) {\n      return item.test(trim);\n    };\n\n    var rLarge = /large/;\n    var rSmall = /small/;\n    var rBoth = /both/;\n    var rMid = /mid/;\n    var rAll = /^all|[^sm]all/;\n    var rFinal = /final/;\n    var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n    var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n    var trimMid = any([rMid, rAll], trimIncludes);\n    var trimFinal = any([rFinal, rAll], trimIncludes); // Parse format string to create raw tokens array.\n\n    var rawTokens = map(template.match(tokenizer), function (token, index) {\n      var type = typeMap(token);\n\n      if (token.slice(0, 1) === \"*\") {\n        token = token.slice(1);\n\n        if (type !== \"escape\" && type !== \"general\") {\n          stopTrim.push(type);\n        }\n      }\n\n      return {\n        index: index,\n        length: token.length,\n        text: \"\",\n        // Replace escaped tokens with the non-escaped token text.\n        token: type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token,\n        // Ignore type on non-moment tokens.\n        type: type === \"escape\" || type === \"general\" ? null : type\n      };\n    }); // Associate text tokens with moment tokens.\n\n    var currentToken = {\n      index: 0,\n      length: 0,\n      token: \"\",\n      text: \"\",\n      type: null\n    };\n    var tokens = [];\n\n    if (useLeftUnits) {\n      rawTokens.reverse();\n    }\n\n    each(rawTokens, function (token) {\n      if (token.type) {\n        if (currentToken.type || currentToken.text) {\n          tokens.push(currentToken);\n        }\n\n        currentToken = token;\n        return;\n      }\n\n      if (useLeftUnits) {\n        currentToken.text = token.token + currentToken.text;\n      } else {\n        currentToken.text += token.token;\n      }\n    });\n\n    if (currentToken.type || currentToken.text) {\n      tokens.push(currentToken);\n    }\n\n    if (useLeftUnits) {\n      tokens.reverse();\n    } // Find unique moment token types in the template in order of\n    // descending magnitude.\n\n\n    var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\")))); // Exit early if there are no moment token types.\n\n    if (!momentTypes.length) {\n      return pluck(tokens, \"text\").join(\"\");\n    } // Calculate values for each moment type in the template.\n    // For processing the settings, values are associated with moment types.\n    // Values will be assigned to tokens at the last step in order to\n    // assume nothing about frequency or order of tokens in the template.\n\n\n    momentTypes = map(momentTypes, function (momentType, index) {\n      // Is this the least-magnitude moment token found?\n      var isSmallest = index + 1 === momentTypes.length; // Is this the greatest-magnitude moment token found?\n\n      var isLargest = !index; // Get the raw value in the current units.\n\n      var rawValue;\n\n      if (momentType === \"years\" || momentType === \"months\") {\n        rawValue = remainderMonths.as(momentType);\n      } else {\n        rawValue = remainder.as(momentType);\n      }\n\n      var wholeValue = Math.floor(rawValue);\n      var decimalValue = rawValue - wholeValue;\n      var token = find(tokens, function (token) {\n        return momentType === token.type;\n      });\n\n      if (isLargest && maxValue && rawValue > maxValue) {\n        isMaxValue = true;\n      }\n\n      if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n        isMinValue = true;\n      } // Note the length of the largest-magnitude moment token:\n      // if it is greater than one and forceLength is not set,\n      // then default forceLength to `true`.\n      //\n      // Rationale is this: If the template is \"h:mm:ss\" and the\n      // moment value is 5 minutes, the user-friendly output is\n      // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n      // even though it has length of two if the template is \"h:mm:ss\";\n      //\n      // If the minutes output should always include the leading zero\n      // even when the hour is trimmed then set `{ forceLength: true }`\n      // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n      // clearly wanted everything padded so we should output \"05:00\";\n      //\n      // If the user wants the full padded output, they can use\n      // template \"hh:mm:ss\" and set `{ trim: false }` to output\n      // \"00:05:00\".\n\n\n      if (isLargest && forceLength === null && token.length > 1) {\n        forceLength = true;\n      } // Update remainder.\n\n\n      remainder.subtract(wholeValue, momentType);\n      remainderMonths.subtract(wholeValue, momentType);\n      return {\n        rawValue: rawValue,\n        wholeValue: wholeValue,\n        // Decimal value is only retained for the least-magnitude\n        // moment type in the format template.\n        decimalValue: isSmallest ? decimalValue : 0,\n        isSmallest: isSmallest,\n        isLargest: isLargest,\n        type: momentType,\n        // Tokens can appear multiple times in a template string,\n        // but all instances must share the same length.\n        tokenLength: token.length\n      };\n    });\n    var truncMethod = trunc ? Math.floor : Math.round;\n\n    var truncate = function (value, places) {\n      var factor = Math.pow(10, places);\n      return truncMethod(value * factor) / factor;\n    };\n\n    var foundFirst = false;\n    var bubbled = false;\n\n    var formatValue = function (momentType, index) {\n      var formatOptions = {\n        useGrouping: useGrouping,\n        groupingSeparator: groupingSeparator,\n        decimalSeparator: decimalSeparator,\n        grouping: grouping,\n        useToLocaleString: useToLocaleString\n      };\n\n      if (useSignificantDigits) {\n        if (significantDigits <= 0) {\n          momentType.rawValue = 0;\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        } else {\n          formatOptions.maximumSignificantDigits = significantDigits;\n          momentType.significantDigits = significantDigits;\n        }\n      }\n\n      if (isMaxValue && !bubbled) {\n        if (momentType.isLargest) {\n          momentType.wholeValue = maxValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n\n      if (isMinValue && !bubbled) {\n        if (momentType.isSmallest) {\n          momentType.wholeValue = minValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n\n      if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n        // Apply precision to least significant token value.\n        if (precision < 0) {\n          momentType.value = truncate(momentType.wholeValue, precision);\n        } else if (precision === 0) {\n          momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n        } else {\n          // precision > 0\n          if (useSignificantDigits) {\n            if (trunc) {\n              momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n            } else {\n              momentType.value = momentType.rawValue;\n            }\n\n            if (momentType.wholeValue) {\n              significantDigits -= momentType.wholeValue.toString().length;\n            }\n          } else {\n            formatOptions.fractionDigits = precision;\n\n            if (trunc) {\n              momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n            } else {\n              momentType.value = momentType.wholeValue + momentType.decimalValue;\n            }\n          }\n        }\n      } else {\n        if (useSignificantDigits && momentType.wholeValue) {\n          // Outer Math.round required here to handle floating point errors.\n          momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n          significantDigits -= momentType.wholeValue.toString().length;\n        } else {\n          momentType.value = momentType.wholeValue;\n        }\n      }\n\n      if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n        formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n        if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n          delete formatOptions.maximumSignificantDigits;\n        }\n      }\n\n      if (!foundFirst && (momentType.value > 0 || trim === \"\"\n      /* trim: false */\n      || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        foundFirst = true;\n      }\n\n      momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n      formatOptions.useGrouping = false;\n      formatOptions.decimalSeparator = \".\";\n      momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n      if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n        momentType.formattedValueMS = formatNumber(momentType.value, {\n          minimumIntegerDigits: 3,\n          useGrouping: false\n        }, \"en\").slice(0, 2);\n      }\n\n      return momentType;\n    }; // Calculate formatted values.\n\n\n    momentTypes = map(momentTypes, formatValue);\n    momentTypes = compact(momentTypes); // Bubble rounded values.\n\n    if (momentTypes.length > 1) {\n      var findType = function (type) {\n        return find(momentTypes, function (momentType) {\n          return momentType.type === type;\n        });\n      };\n\n      var bubbleTypes = function (bubble) {\n        var bubbleMomentType = findType(bubble.type);\n\n        if (!bubbleMomentType) {\n          return;\n        }\n\n        each(bubble.targets, function (target) {\n          var targetMomentType = findType(target.type);\n\n          if (!targetMomentType) {\n            return;\n          }\n\n          if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n            bubbleMomentType.rawValue = 0;\n            bubbleMomentType.wholeValue = 0;\n            bubbleMomentType.decimalValue = 0;\n            targetMomentType.rawValue += 1;\n            targetMomentType.wholeValue += 1;\n            targetMomentType.decimalValue = 0;\n            targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n            bubbled = true;\n          }\n        });\n      };\n\n      each(bubbles, bubbleTypes);\n    } // Recalculate formatted values.\n\n\n    if (bubbled) {\n      foundFirst = false;\n      significantDigits = significantDigitsCache;\n      momentTypes = map(momentTypes, formatValue);\n      momentTypes = compact(momentTypes);\n    }\n\n    if (outputTypes && !(isMaxValue && !settings.trim)) {\n      momentTypes = map(momentTypes, function (momentType) {\n        if (find(outputTypes, function (outputType) {\n          return momentType.type === outputType;\n        })) {\n          return momentType;\n        }\n\n        return null;\n      });\n      momentTypes = compact(momentTypes);\n    } else {\n      // Trim Large.\n      if (trimLarge) {\n        momentTypes = rest(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - the smallest moment type\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n        });\n      } // Largest.\n\n\n      if (largest && momentTypes.length) {\n        momentTypes = momentTypes.slice(0, largest);\n      } // Trim Small.\n\n\n      if (trimSmall && momentTypes.length > 1) {\n        momentTypes = initial(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          // - the largest momentType\n          return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n        });\n      } // Trim Mid.\n\n\n      if (trimMid) {\n        momentTypes = map(momentTypes, function (momentType, index) {\n          if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n            return null;\n          }\n\n          return momentType;\n        });\n        momentTypes = compact(momentTypes);\n      } // Trim Final.\n\n\n      if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n        momentTypes = [];\n      }\n    }\n\n    if (returnMomentTypes) {\n      return momentTypes;\n    } // Localize and pluralize unit labels.\n\n\n    each(tokens, function (token) {\n      var key = momentTokens[token.type];\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n\n      if (!key || !momentType) {\n        return;\n      }\n\n      var values = momentType.formattedValueEn.split(\".\");\n      values[0] = parseInt(values[0], 10);\n\n      if (values[1]) {\n        values[1] = parseFloat(\"0.\" + values[1], 10);\n      } else {\n        values[1] = null;\n      }\n\n      var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n      var labels = durationGetLabels(key, localeData);\n      var autoLocalized = false;\n      var pluralizedLabels = {}; // Auto-Localized unit labels.\n\n      each(localeData._durationLabelTypes, function (labelType) {\n        var label = find(labels, function (label) {\n          return label.type === labelType.type && label.key === pluralKey;\n        });\n\n        if (label) {\n          pluralizedLabels[label.type] = label.label;\n\n          if (stringIncludes(token.text, labelType.string)) {\n            token.text = token.text.replace(labelType.string, label.label);\n            autoLocalized = true;\n          }\n        }\n      }); // Auto-pluralized unit labels.\n\n      if (usePlural && !autoLocalized) {\n        labels.sort(durationLabelCompare);\n        each(labels, function (label) {\n          if (pluralizedLabels[label.type] === label.label) {\n            if (stringIncludes(token.text, label.label)) {\n              // Stop checking this token if its label is already\n              // correctly pluralized.\n              return false;\n            } // Skip this label if it is correct, but not present in\n            // the token's text.\n\n\n            return;\n          }\n\n          if (stringIncludes(token.text, label.label)) {\n            // Replece this token's label and stop checking.\n            token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n            return false;\n          }\n        });\n      }\n    }); // Build ouptut.\n\n    tokens = map(tokens, function (token) {\n      if (!token.type) {\n        return token.text;\n      }\n\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n\n      if (!momentType) {\n        return \"\";\n      }\n\n      var out = \"\";\n\n      if (useLeftUnits) {\n        out += token.text;\n      }\n\n      if (isNegative && isMaxValue || !isNegative && isMinValue) {\n        out += \"< \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n\n      if (isNegative && isMinValue || !isNegative && isMaxValue) {\n        out += \"> \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n\n      if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        out += \"-\";\n        isNegative = false;\n      }\n\n      if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n        out += momentType.formattedValueMS;\n      } else {\n        out += momentType.formattedValue;\n      }\n\n      if (!useLeftUnits) {\n        out += token.text;\n      }\n\n      return out;\n    }); // Trim leading and trailing comma, space, colon, and dot.\n\n    return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n  } // defaultFormatTemplate\n\n\n  function defaultFormatTemplate() {\n    var dur = this.duration;\n\n    var findType = function findType(type) {\n      return dur._data[type];\n    };\n\n    var firstType = find(this.types, findType);\n    var lastType = findLast(this.types, findType); // Default template strings for each duration dimension type.\n\n    switch (firstType) {\n      case \"milliseconds\":\n        return \"S __\";\n\n      case \"seconds\": // Fallthrough.\n\n      case \"minutes\":\n        return \"*_MS_\";\n\n      case \"hours\":\n        return \"_HMS_\";\n\n      case \"days\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"d __\";\n        }\n\n      case \"weeks\":\n        if (firstType === lastType) {\n          return \"w __\";\n        }\n\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n\n        return \"w __, d __, h __\";\n\n      case \"months\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"M __\";\n        }\n\n      case \"years\":\n        if (firstType === lastType) {\n          return \"y __\";\n        }\n\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n\n        return \"y __, M __, d __\";\n\n      default:\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n\n        return \"y __, d __, h __, m __, s __\";\n    }\n  } // init\n\n\n  function init(context) {\n    if (!context) {\n      throw \"Moment Duration Format init cannot find moment instance.\";\n    }\n\n    context.duration.format = durationsFormat;\n    context.duration.fn.format = durationFormat;\n    context.duration.fn.format.defaults = {\n      // Many options are defaulted to `null` to distinguish between\n      // 'not set' and 'set to `false`'\n      // trim\n      // Can be a string, a delimited list of strings, an array of strings,\n      // or a boolean.\n      // \"large\" - will trim largest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"small\" - will trim smallest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"both\" - will execute \"large\" trim then \"small\" trim.\n      // \"mid\" - will trim any zero-value tokens that are not the first or\n      // last tokens. Usually used in conjunction with \"large\" or \"both\".\n      // e.g. \"large mid\" or \"both mid\".\n      // \"final\" - will trim the final token if it is zero-value. Use this\n      // option with \"large\" or \"both\" to output an empty string when\n      // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n      // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n      // \"left\" - maps to \"large\" to support plugin's version 1 API.\n      // \"right\" - maps to \"large\" to support plugin's version 1 API.\n      // `false` - template tokens are not trimmed.\n      // `true` - treated as \"large\".\n      // `null` - treated as \"large\".\n      trim: null,\n      // stopTrim\n      // A moment token string, a delimited set of moment token strings,\n      // or an array of moment token strings. Trimming will stop when a token\n      // listed in this option is reached. A \"*\" character in the format\n      // template string will also mark a moment token as stopTrim.\n      // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n      stopTrim: null,\n      // largest\n      // Set to a positive integer to output only the \"n\" largest-magnitude\n      // moment tokens that have a value. All lesser-magnitude moment tokens\n      // will be ignored. This option takes effect even if `trim` is set\n      // to `false`.\n      largest: null,\n      // maxValue\n      // Use `maxValue` to render generalized output for large duration values,\n      // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n      /// applied to the greatest-magnitude moment token in the format template.\n      maxValue: null,\n      // minValue\n      // Use `minValue` to render generalized output for small duration values,\n      // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n      // applied to the least-magnitude moment token in the format template.\n      minValue: null,\n      // precision\n      // If a positive integer, number of decimal fraction digits to render.\n      // If a negative integer, number of integer place digits to truncate to 0.\n      // If `useSignificantDigits` is set to `true` and `precision` is a positive\n      // integer, sets the maximum number of significant digits used in the\n      // formatted output.\n      precision: 0,\n      // trunc\n      // Default behavior rounds final token value. Set to `true` to\n      // truncate final token value, which was the default behavior in\n      // version 1 of this plugin.\n      trunc: false,\n      // forceLength\n      // Force first moment token with a value to render at full length\n      // even when template is trimmed and first moment token has length of 1.\n      forceLength: null,\n      // userLocale\n      // Formatted numerical output is rendered using `toLocaleString`\n      // and the locale of the user's environment. Set this option to render\n      // numerical output using a different locale. Unit names are rendered\n      // and detected using the locale set in moment.js, which can be different\n      // from the locale of user's environment.\n      userLocale: null,\n      // usePlural\n      // Will automatically singularize or pluralize unit names when they\n      // appear in the text associated with each moment token. Standard and\n      // short unit labels are singularized and pluralized, based on locale.\n      // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n      // of \"1 seconds\" or \"1 secs\". The default pluralization function\n      // renders a plural label for a value with decimal precision.\n      // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n      // Label types and pluralization function are configurable in the\n      // localeData extensions.\n      usePlural: true,\n      // useLeftUnits\n      // The text to the right of each moment token in a format string\n      // is treated as that token's units for the purposes of trimming,\n      // singularizing, and auto-localizing.\n      // e.g. \"h [hours], m [minutes], s [seconds]\".\n      // To properly singularize or localize a format string such as\n      // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n      // to the left of each moment token, set useLeftUnits to `true`.\n      // This plugin is not tested in the context of rtl text.\n      useLeftUnits: false,\n      // useGrouping\n      // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useGrouping: true,\n      // useSignificantDigits\n      // Treat the `precision` option as the maximum significant digits\n      // to be rendered. Precision must be a positive integer. Significant\n      // digits extend across unit types,\n      // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n      // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useSignificantDigits: false,\n      // template\n      // The template string used to format the duration. May be a function\n      // or a string. Template functions are executed with the `this` binding\n      // of the settings object so that template strings may be dynamically\n      // generated based on the duration object (accessible via `this.duration`)\n      // or any of the other settings. Leading and trailing space, comma,\n      // period, and colon characters are trimmed from the resulting string.\n      template: defaultFormatTemplate,\n      // useToLocaleString\n      // Set this option to `false` to ignore the `toLocaleString` feature\n      // test and force the use of the `formatNumber` fallback function\n      // included in this plugin.\n      useToLocaleString: true,\n      // formatNumber fallback options.\n      // When `toLocaleString` is detected and passes the feature test, the\n      // following options will have no effect: `toLocaleString` will be used\n      // for formatting and the grouping separator, decimal separator, and\n      // integer digit grouping will be determined by the user locale.\n      // groupingSeparator\n      // The integer digit grouping separator used when using the fallback\n      // formatNumber function.\n      groupingSeparator: \",\",\n      // decimalSeparator\n      // The decimal separator used when using the fallback formatNumber\n      // function.\n      decimalSeparator: \".\",\n      // grouping\n      // The integer digit grouping used when using the fallback formatNumber\n      // function. Must be an array. The default value of `[3]` gives the\n      // standard 3-digit thousand/million/billion digit groupings for the\n      // \"en\" locale. Setting this option to `[3, 2]` would generate the\n      // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n      grouping: [3]\n    };\n    context.updateLocale('en', engLocale);\n  } // Run feature tests for `Number#toLocaleString`.\n\n\n  var toLocaleStringFormatter = function (number, locale, options) {\n    return number.toLocaleString(locale, options);\n  };\n\n  toLocaleStringWorks = toLocaleStringSupportsLocales() && featureTestFormatter(toLocaleStringFormatter);\n  toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestFormatterRounding(toLocaleStringFormatter); // Run feature tests for `Intl.NumberFormat#format`.\n\n  var intlNumberFormatFormatter = function (number, locale, options) {\n    if (typeof window !== 'undefined' && window && window.Intl && window.Intl.NumberFormat) {\n      return window.Intl.NumberFormat(locale, options).format(number);\n    }\n  };\n\n  intlNumberFormatWorks = featureTestFormatter(intlNumberFormatFormatter);\n  intlNumberFormatRoundingWorks = intlNumberFormatWorks && featureTestFormatterRounding(intlNumberFormatFormatter); // Initialize duration format on the global moment instance.\n\n  init(moment); // Return the init function so that duration format can be\n  // initialized on other moment instances.\n\n  return init;\n});","map":{"version":3,"sources":["/home/tomek/social-media/carrot-studio/CarrotHR/node_modules/moment-duration-format/lib/moment-duration-format.js"],"names":["root","factory","define","amd","exports","module","require","e","momentDurationFormatSetup","moment","toLocaleStringWorks","toLocaleStringRoundingWorks","intlNumberFormatWorks","intlNumberFormatRoundingWorks","types","split","bubbles","type","targets","value","stringIncludes","str","search","length","indexOf","repeatZero","qty","result","stringRound","digits","digitsArray","reverse","i","carry","parseInt","toString","push","join","cachedNumberFormat","locale","options","optionsString","map","keys","sort","key","cacheKey","cache","Intl","NumberFormat","formatNumber","number","userLocale","useToLocaleString","useGrouping","grouping","slice","maximumSignificantDigits","minimumIntegerDigits","fractionDigits","groupingSeparator","decimalSeparator","localeStringOptions","maximumFractionDigits","minimumFractionDigits","roundingOptions","extend","parseFloat","format","toLocaleString","numberString","toPrecision","toFixed","integerString","fractionString","exponentString","temp","integerLength","fractionLength","digitCount","replace","exponent","Math","abs","formattedString","group","shift","durationLabelCompare","a","b","label","durationGetLabels","token","localeData","labels","each","localeDataKey","labelType","toLowerCase","labelKey","durationPluralKey","integerValue","decimalValue","engLocale","durationLabelsStandard","S","SS","s","ss","m","mm","h","hh","d","dd","w","ww","M","MM","y","yy","durationLabelsShort","durationTimeTemplates","HMS","HM","MS","durationLabelTypes","string","isArray","array","Object","prototype","call","isObject","obj","findLast","callback","index","find","max","match","item","ret","pluck","prop","compact","unique","_a","intersection","_b","rest","initial","reversed","hasOwnProperty","any","flatten","child","concat","toLocaleStringSupportsLocales","name","featureTestFormatterRounding","formatter","featureTestFormatter","passed","durationsFormat","args","arguments","settings","durations","arg","template","precision","returnMomentTypes","formattedDurations","dur","outputTypes","largest","durationFormat","defaults","asMilliseconds","asMonths","isValid","isNegative","remainder","duration","remainderMonths","momentTokens","years","months","weeks","days","hours","minutes","seconds","milliseconds","tokenDefs","escape","general","typeMap","test","tokenizer","RegExp","source","apply","stopTrim","_durationTimeTemplates","useLeftUnits","usePlural","forceLength","trunc","useSignificantDigits","significantDigits","significantDigitsCache","minValue","isMinValue","maxValue","isMaxValue","trim","trimIncludes","rLarge","rSmall","rBoth","rMid","rAll","rFinal","trimLarge","trimSmall","trimMid","trimFinal","rawTokens","text","currentToken","tokens","momentTypes","momentType","isSmallest","isLargest","rawValue","as","wholeValue","floor","subtract","tokenLength","truncMethod","round","truncate","places","factor","pow","foundFirst","bubbled","formatValue","formatOptions","formattedValue","formattedValueEn","formattedValueMS","findType","bubbleTypes","bubble","bubbleMomentType","target","targetMomentType","outputType","values","pluralKey","autoLocalized","pluralizedLabels","_durationLabelTypes","out","defaultFormatTemplate","_data","firstType","lastType","init","context","fn","updateLocale","toLocaleStringFormatter","intlNumberFormatFormatter","window"],"mappings":"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","sourcesContent":["/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['moment'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but only CommonJS-like\n        // enviroments that support module.exports, like Node.\n        try {\n            module.exports = factory(require('moment'));\n        } catch (e) {\n            // If moment is not available, leave the setup up to the user.\n            // Like when using moment-timezone or similar moment-based package.\n            module.exports = factory;\n        }\n    }\n\n    if (root) {\n        // Globals.\n        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n    }\n})(this, function (moment) {\n    // `Number#tolocaleString` is tested on plugin initialization.\n    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n    // native function will be used to generate formatted output. If the feature\n    // test fails, the fallback format function internal to this plugin will be\n    // used.\n    var toLocaleStringWorks = false;\n\n    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `toLocaleString` will be used for formatting,\n    // the plugin will \"pre-round\" number values using the fallback number format\n    // function before passing them to `toLocaleString` for final formatting.\n    var toLocaleStringRoundingWorks = false;\n\n    // `Intl.NumberFormat#format` is tested on plugin initialization.\n    // If the feature test passes, `intlNumberFormatRoundingWorks` will be set to\n    // `true` and the native function will be used to generate formatted output.\n    // If the feature test fails, either `Number#tolocaleString` (if\n    // `toLocaleStringWorks` is `true`), or the fallback format function internal\n    //  to this plugin will be used.\n    var intlNumberFormatWorks = false;\n\n    // `Intl.NumberFormat#format` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `Intl.NumberFormat#format` will be used for\n    // formatting, the plugin will \"pre-round\" number values using the fallback number\n    // format function before passing them to `Intl.NumberFormat#format` for final\n    // formatting.\n    var intlNumberFormatRoundingWorks = false;\n\n    // Token type names in order of descending magnitude.\n    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\n    var bubbles = [\n        {\n            type: \"seconds\",\n            targets: [\n                { type: \"minutes\", value: 60 },\n                { type: \"hours\", value: 3600 },\n                { type: \"days\", value: 86400 },\n                { type: \"weeks\", value: 604800 },\n                { type: \"months\", value: 2678400 },\n                { type: \"years\", value: 31536000 }\n            ]\n        },\n        {\n            type: \"minutes\",\n            targets: [\n                { type: \"hours\", value: 60 },\n                { type: \"days\", value: 1440 },\n                { type: \"weeks\", value: 10080 },\n                { type: \"months\", value: 44640 },\n                { type: \"years\", value: 525600 }\n            ]\n        },\n        {\n            type: \"hours\",\n            targets: [\n                { type: \"days\", value: 24 },\n                { type: \"weeks\", value: 168 },\n                { type: \"months\", value: 744 },\n                { type: \"years\", value: 8760 }\n            ]\n        },\n        {\n            type: \"days\",\n            targets: [\n                { type: \"weeks\", value: 7 },\n                { type: \"months\", value: 31 },\n                { type: \"years\", value: 365 }\n            ]\n        },\n        {\n            type: \"months\",\n            targets: [\n                { type: \"years\", value: 12 }\n            ]\n        }\n    ];\n\n    // stringIncludes\n    function stringIncludes(str, search) {\n        if (search.length > str.length) {\n          return false;\n        }\n\n        return str.indexOf(search) !== -1;\n    }\n\n    // repeatZero(qty)\n    // Returns \"0\" repeated `qty` times.\n    // `qty` must be a integer >= 0.\n    function repeatZero(qty) {\n        var result = \"\";\n\n        while (qty) {\n            result += \"0\";\n            qty -= 1;\n        }\n\n        return result;\n    }\n\n    function stringRound(digits) {\n        var digitsArray = digits.split(\"\").reverse();\n        var i = 0;\n        var carry = true;\n\n        while (carry && i < digitsArray.length) {\n            if (i) {\n                if (digitsArray[i] === \"9\") {\n                    digitsArray[i] = \"0\";\n                } else {\n                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n                    carry = false;\n                }\n            } else {\n                if (parseInt(digitsArray[i], 10) < 5) {\n                    carry = false;\n                }\n\n                digitsArray[i] = \"0\";\n            }\n\n            i += 1;\n        }\n\n        if (carry) {\n            digitsArray.push(\"1\");\n        }\n\n        return digitsArray.reverse().join(\"\");\n    }\n\n    // cachedNumberFormat\n    // Returns an `Intl.NumberFormat` instance for the given locale and configuration.\n    // On first use of a particular configuration, the instance is cached for fast\n    // repeat access.\n    function cachedNumberFormat(locale, options) {\n        // Create a sorted, stringified version of `options`\n        // for use as part of the cache key\n        var optionsString = map(\n            keys(options).sort(),\n            function(key) {\n                return key + ':' + options[key];\n            }\n        ).join(',');\n\n        // Set our cache key\n        var cacheKey = locale + '+' + optionsString;\n\n        // If we don't have this configuration cached, configure and cache it\n        if (!cachedNumberFormat.cache[cacheKey]) {\n            cachedNumberFormat.cache[cacheKey] = Intl.NumberFormat(locale, options);\n        }\n\n        // Return the cached version of this configuration\n        return cachedNumberFormat.cache[cacheKey];\n    }\n    cachedNumberFormat.cache = {};\n\n    // formatNumber\n    // Formats any number greater than or equal to zero using these options:\n    // - userLocale\n    // - useToLocaleString\n    // - useGrouping\n    // - grouping\n    // - maximumSignificantDigits\n    // - minimumIntegerDigits\n    // - fractionDigits\n    // - groupingSeparator\n    // - decimalSeparator\n    //\n    // `useToLocaleString` will use `Intl.NumberFormat` or `toLocaleString` for formatting.\n    // `userLocale` option is passed through to the formatting function.\n    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n    function formatNumber(number, options, userLocale) {\n        var useToLocaleString = options.useToLocaleString;\n        var useGrouping = options.useGrouping;\n        var grouping = useGrouping && options.grouping.slice();\n        var maximumSignificantDigits = options.maximumSignificantDigits;\n        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n        var fractionDigits = options.fractionDigits || 0;\n        var groupingSeparator = options.groupingSeparator;\n        var decimalSeparator = options.decimalSeparator;\n\n        if (useToLocaleString && userLocale) {\n            var localeStringOptions = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                useGrouping: useGrouping\n            };\n\n            if (fractionDigits) {\n                localeStringOptions.maximumFractionDigits = fractionDigits;\n                localeStringOptions.minimumFractionDigits = fractionDigits;\n            }\n\n            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n            // when maximumSignificantDigits is set. See #96.\n            if (maximumSignificantDigits && number > 0) {\n                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n            }\n\n            if (intlNumberFormatWorks) {\n                if (!intlNumberFormatRoundingWorks) {\n                    var roundingOptions = extend({}, options);\n                    roundingOptions.useGrouping = false;\n                    roundingOptions.decimalSeparator = \".\";\n                    number = parseFloat(formatNumber(number, roundingOptions), 10);\n                }\n\n                return cachedNumberFormat(userLocale, localeStringOptions).format(number);\n            } else {\n                if (!toLocaleStringRoundingWorks) {\n                    var roundingOptions = extend({}, options);\n                    roundingOptions.useGrouping = false;\n                    roundingOptions.decimalSeparator = \".\";\n                    number = parseFloat(formatNumber(number, roundingOptions), 10);\n                }\n\n                return number.toLocaleString(userLocale, localeStringOptions);\n            }\n        }\n\n        var numberString;\n\n        // Add 1 to digit output length for floating point errors workaround. See below.\n        if (maximumSignificantDigits) {\n            numberString = number.toPrecision(maximumSignificantDigits + 1);\n        } else {\n            numberString = number.toFixed(fractionDigits + 1);\n        }\n\n        var integerString;\n        var fractionString;\n        var exponentString;\n\n        var temp = numberString.split(\"e\");\n\n        exponentString = temp[1] || \"\";\n\n        temp = temp[0].split(\".\");\n\n        fractionString = temp[1] || \"\";\n        integerString = temp[0] || \"\";\n\n        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n        // (3.55).toFixed(1); --> \"3.5\"\n        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n        // (123.55 - 120); --> 3.549999999999997\n        // (123.55 - 120).toFixed(2); --> \"3.55\"\n        // Round by examing the string output of the next digit.\n\n        // *************** Implement String Rounding here ***********************\n        // Check integerString + fractionString length of toPrecision before rounding.\n        // Check length of fractionString from toFixed output before rounding.\n        var integerLength = integerString.length;\n        var fractionLength = fractionString.length;\n        var digitCount = integerLength + fractionLength;\n        var digits = integerString + fractionString;\n\n        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n            // Round digits.\n            digits = stringRound(digits);\n\n            if (digits.length === digitCount + 1) {\n                integerLength = integerLength + 1;\n            }\n\n            // Discard final fractionDigit.\n            if (fractionLength) {\n                digits = digits.slice(0, -1);\n            }\n\n            // Separate integer and fraction.\n            integerString = digits.slice(0, integerLength);\n            fractionString = digits.slice(integerLength);\n        }\n\n        // Trim trailing zeroes from fractionString because toPrecision outputs\n        // precision, not significant digits.\n        if (maximumSignificantDigits) {\n            fractionString = fractionString.replace(/0*$/, \"\");\n        }\n\n        // Handle exponent.\n        var exponent = parseInt(exponentString, 10);\n\n        if (exponent > 0) {\n            if (fractionString.length <= exponent) {\n                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\n                integerString = integerString + fractionString;\n                fractionString = \"\";\n            } else {\n                integerString = integerString + fractionString.slice(0, exponent);\n                fractionString = fractionString.slice(exponent);\n            }\n        } else if (exponent < 0) {\n            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\n            integerString = \"0\";\n        }\n\n        if (!maximumSignificantDigits) {\n            // Trim or pad fraction when not using maximumSignificantDigits.\n            fractionString = fractionString.slice(0, fractionDigits);\n\n            if (fractionString.length < fractionDigits) {\n                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n            }\n\n            // Pad integer when using minimumIntegerDigits\n            // and not using maximumSignificantDigits.\n            if (integerString.length < minimumIntegerDigits) {\n                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n            }\n        }\n\n        var formattedString = \"\";\n\n        // Handle grouping.\n        if (useGrouping) {\n            temp = integerString;\n            var group;\n\n            while (temp.length) {\n                if (grouping.length) {\n                    group = grouping.shift();\n                }\n\n                if (formattedString) {\n                    formattedString = groupingSeparator + formattedString;\n                }\n\n                formattedString = temp.slice(-group) + formattedString;\n\n                temp = temp.slice(0, -group);\n            }\n        } else {\n            formattedString = integerString;\n        }\n\n        // Add decimalSeparator and fraction.\n        if (fractionString) {\n            formattedString = formattedString + decimalSeparator + fractionString;\n        }\n\n        return formattedString;\n    }\n\n    // durationLabelCompare\n    function durationLabelCompare(a, b) {\n        if (a.label.length > b.label.length) {\n            return -1;\n        }\n\n        if (a.label.length < b.label.length) {\n            return 1;\n        }\n\n        // a must be equal to b\n        return 0;\n    }\n\n    // durationGetLabels\n    function durationGetLabels(token, localeData) {\n        var labels = [];\n\n        each(keys(localeData), function (localeDataKey) {\n            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n                return;\n            }\n\n            var labelType = localeDataKey.slice(15).toLowerCase();\n\n            each(keys(localeData[localeDataKey]), function (labelKey) {\n                if (labelKey.slice(0, 1) === token) {\n                    labels.push({\n                        type: labelType,\n                        key: labelKey,\n                        label: localeData[localeDataKey][labelKey]\n                    });\n                }\n            });\n        });\n\n        return labels;\n    }\n\n    // durationPluralKey\n    function durationPluralKey(token, integerValue, decimalValue) {\n        // Singular for a value of `1`, but not for `1.0`.\n        if (integerValue === 1 && decimalValue === null) {\n            return token;\n        }\n\n        return token + token;\n    }\n\n    var engLocale = {\n        durationLabelsStandard: {\n            S: 'millisecond',\n            SS: 'milliseconds',\n            s: 'second',\n            ss: 'seconds',\n            m: 'minute',\n            mm: 'minutes',\n            h: 'hour',\n            hh: 'hours',\n            d: 'day',\n            dd: 'days',\n            w: 'week',\n            ww: 'weeks',\n            M: 'month',\n            MM: 'months',\n            y: 'year',\n            yy: 'years'\n        },\n        durationLabelsShort: {\n            S: 'msec',\n            SS: 'msecs',\n            s: 'sec',\n            ss: 'secs',\n            m: 'min',\n            mm: 'mins',\n            h: 'hr',\n            hh: 'hrs',\n            d: 'dy',\n            dd: 'dys',\n            w: 'wk',\n            ww: 'wks',\n            M: 'mo',\n            MM: 'mos',\n            y: 'yr',\n            yy: 'yrs'\n        },\n        durationTimeTemplates: {\n            HMS: 'h:mm:ss',\n            HM: 'h:mm',\n            MS: 'm:ss'\n        },\n        durationLabelTypes: [\n            { type: \"standard\", string: \"__\" },\n            { type: \"short\", string: \"_\" }\n        ],\n        durationPluralKey: durationPluralKey\n    };\n\n    // isArray\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === \"[object Array]\";\n    }\n\n    // isObject\n    function isObject(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Object]\";\n    }\n\n    // findLast\n    function findLast(array, callback) {\n        var index = array.length;\n\n        while (index -= 1) {\n            if (callback(array[index])) { return array[index]; }\n        }\n    }\n\n    // find\n    function find(array, callback) {\n        var index = 0;\n\n        var max = array && array.length || 0;\n\n        var match;\n\n        if (typeof callback !== \"function\") {\n            match = callback;\n            callback = function (item) {\n                return item === match;\n            };\n        }\n\n        while (index < max) {\n            if (callback(array[index])) { return array[index]; }\n            index += 1;\n        }\n    }\n\n    // each\n    function each(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return; }\n\n        while (index < max) {\n            if (callback(array[index], index) === false) { return; }\n            index += 1;\n        }\n    }\n\n    // map\n    function map(array, callback) {\n        var index = 0,\n            max = array.length,\n            ret = [];\n\n        if (!array || !max) { return ret; }\n\n        while (index < max) {\n            ret[index] = callback(array[index], index);\n            index += 1;\n        }\n\n        return ret;\n    }\n\n    // pluck\n    function pluck(array, prop) {\n        return map(array, function (item) {\n            return item[prop];\n        });\n    }\n\n    // compact\n    function compact(array) {\n        var ret = [];\n\n        each(array, function (item) {\n            if (item) { ret.push(item); }\n        });\n\n        return ret;\n    }\n\n    // unique\n    function unique(array) {\n        var ret = [];\n\n        each(array, function (_a) {\n            if (!find(ret, _a)) { ret.push(_a); }\n        });\n\n        return ret;\n    }\n\n    // intersection\n    function intersection(a, b) {\n        var ret = [];\n\n        each(a, function (_a) {\n            each(b, function (_b) {\n                if (_a === _b) { ret.push(_a); }\n            });\n        });\n\n        return unique(ret);\n    }\n\n    // rest\n    function rest(array, callback) {\n        var ret = [];\n\n        each(array, function (item, index) {\n            if (!callback(item)) {\n                ret = array.slice(index);\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    // initial\n    function initial(array, callback) {\n        var reversed = array.slice().reverse();\n\n        return rest(reversed, callback).reverse();\n    }\n\n    // extend\n    function extend(a, b) {\n        for (var key in b) {\n            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n        }\n\n        return a;\n    }\n\n    // keys\n    function keys(a) {\n        var ret = [];\n\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) { ret.push(key); }\n        }\n\n        return ret;\n    }\n\n    // any\n    function any(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return false; }\n\n        while (index < max) {\n            if (callback(array[index], index) === true) { return true; }\n            index += 1;\n        }\n\n        return false;\n    }\n\n    // flatten\n    function flatten(array) {\n        var ret = [];\n\n        each(array, function(child) {\n            ret = ret.concat(child);\n        });\n\n        return ret;\n    }\n\n    function toLocaleStringSupportsLocales() {\n        var number = 0;\n        try {\n            number.toLocaleString('i');\n        } catch (e) {\n            return e.name === 'RangeError';\n        }\n        return false;\n    }\n\n    function featureTestFormatterRounding(formatter) {\n        return formatter(3.55, \"en\", {\n            useGrouping: false,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1\n        }) === \"3.6\";\n    }\n\n    function featureTestFormatter(formatter) {\n        var passed = true;\n\n        // Test minimumIntegerDigits.\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 1 }) === \"1\";\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 2 }) === \"01\";\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 3 }) === \"001\";\n        if (!passed) { return false; }\n\n        // Test maximumFractionDigits and minimumFractionDigits.\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n        if (!passed) { return false; }\n\n        // Test maximumSignificantDigits.\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 1 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 2 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 3 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n        if (!passed) { return false; }\n\n        // Test grouping.\n        passed = passed && formatter(1000, \"en\", { useGrouping: true }) === \"1,000\";\n        passed = passed && formatter(1000, \"en\", { useGrouping: false }) === \"1000\";\n        if (!passed) { return false; }\n\n        return true;\n    }\n\n    // durationsFormat(durations [, template] [, precision] [, settings])\n    function durationsFormat() {\n        var args = [].slice.call(arguments);\n        var settings = {};\n        var durations;\n\n        // Parse arguments.\n        each(args, function (arg, index) {\n            if (!index) {\n                if (!isArray(arg)) {\n                    throw \"Expected array as the first argument to durationsFormat.\";\n                }\n\n                durations = arg;\n            }\n\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        if (!durations || !durations.length) {\n            return [];\n        }\n\n        settings.returnMomentTypes = true;\n\n        var formattedDurations = map(durations, function (dur) {\n            return dur.format(settings);\n        });\n\n        // Merge token types from all durations.\n        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\n        var largest = settings.largest;\n\n        if (largest) {\n            outputTypes = outputTypes.slice(0, largest);\n        }\n\n        settings.returnMomentTypes = false;\n        settings.outputTypes = outputTypes;\n\n        return map(durations, function (dur) {\n            return dur.format(settings);\n        });\n    }\n\n    // durationFormat([template] [, precision] [, settings])\n    function durationFormat() {\n\n        var args = [].slice.call(arguments);\n        var settings = extend({}, this.format.defaults);\n\n        // Keep a shadow copy of this moment for calculating remainders.\n        // Perform all calculations on positive duration value, handle negative\n        // sign at the very end.\n        var asMilliseconds = this.asMilliseconds();\n        var asMonths = this.asMonths();\n\n        // Treat invalid durations as having a value of 0 milliseconds.\n        if (typeof this.isValid === \"function\" && this.isValid() === false) {\n            asMilliseconds = 0;\n            asMonths = 0;\n        }\n\n        var isNegative = asMilliseconds < 0;\n\n        // Two shadow copies are needed because of the way moment.js handles\n        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n        // Parse arguments.\n        each(args, function (arg) {\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        var momentTokens = {\n            years: \"y\",\n            months: \"M\",\n            weeks: \"w\",\n            days: \"d\",\n            hours: \"h\",\n            minutes: \"m\",\n            seconds: \"s\",\n            milliseconds: \"S\"\n        };\n\n        var tokenDefs = {\n            escape: /\\[(.+?)\\]/,\n            years: /\\*?[Yy]+/,\n            months: /\\*?M+/,\n            weeks: /\\*?[Ww]+/,\n            days: /\\*?[Dd]+/,\n            hours: /\\*?[Hh]+/,\n            minutes: /\\*?m+/,\n            seconds: /\\*?s+/,\n            milliseconds: /\\*?S+/,\n            general: /.+?/\n        };\n\n        // Types array is available in the template function.\n        settings.types = types;\n\n        var typeMap = function (token) {\n            return find(types, function (type) {\n                return tokenDefs[type].test(token);\n            });\n        };\n\n        var tokenizer = new RegExp(map(types, function (type) {\n            return tokenDefs[type].source;\n        }).join(\"|\"), \"g\");\n\n        // Current duration object is available in the template function.\n        settings.duration = this;\n\n        // Eval template function and cache template string.\n        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n        // outputTypes is an array of moment token types that determines\n        // the tokens returned in formatted output. This option overrides\n        // trim, largest, stopTrim, etc.\n        var outputTypes = settings.outputTypes;\n\n        // returnMomentTypes is a boolean that sets durationFormat to return\n        // the processed momentTypes instead of formatted output.\n        var returnMomentTypes = settings.returnMomentTypes;\n\n        var largest = settings.largest;\n\n        // Setup stopTrim array of token types.\n        var stopTrim = [];\n\n        if (!outputTypes) {\n            if (isArray(settings.stopTrim)) {\n                settings.stopTrim = settings.stopTrim.join(\"\");\n            }\n\n            // Parse stopTrim string to create token types array.\n            if (settings.stopTrim) {\n                each(settings.stopTrim.match(tokenizer), function (token) {\n                    var type = typeMap(token);\n\n                    if (type === \"escape\" || type === \"general\") {\n                        return;\n                    }\n\n                    stopTrim.push(type);\n                });\n            }\n        }\n\n        // Cache moment's locale data.\n        var localeData = moment.localeData();\n\n        if (!localeData) {\n            localeData = {};\n        }\n\n        // Fall back to this plugin's `eng` extension.\n        each(keys(engLocale), function (key) {\n            if (typeof engLocale[key] === \"function\") {\n                if (!localeData[key]) {\n                    localeData[key] = engLocale[key];\n                }\n\n                return;\n            }\n\n            if (!localeData[\"_\" + key]) {\n                localeData[\"_\" + key] = engLocale[key];\n            }\n        });\n\n        // Replace Duration Time Template strings.\n        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n        each(keys(localeData._durationTimeTemplates), function (item) {\n            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n        });\n\n        // Determine user's locale.\n        var userLocale = settings.userLocale || moment.locale();\n\n        var useLeftUnits = settings.useLeftUnits;\n        var usePlural = settings.usePlural;\n        var precision = settings.precision;\n        var forceLength = settings.forceLength;\n        var useGrouping = settings.useGrouping;\n        var trunc = settings.trunc;\n\n        // Use significant digits only when precision is greater than 0.\n        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n        var significantDigits = useSignificantDigits ? settings.precision : 0;\n        var significantDigitsCache = significantDigits;\n\n        var minValue = settings.minValue;\n        var isMinValue = false;\n\n        var maxValue = settings.maxValue;\n        var isMaxValue = false;\n\n        // formatNumber fallback options.\n        var useToLocaleString = settings.useToLocaleString;\n        var groupingSeparator = settings.groupingSeparator;\n        var decimalSeparator = settings.decimalSeparator;\n        var grouping = settings.grouping;\n\n        useToLocaleString = useToLocaleString && (toLocaleStringWorks || intlNumberFormatWorks);\n\n        // Trim options.\n        var trim = settings.trim;\n\n        if (isArray(trim)) {\n            trim = trim.join(\" \");\n        }\n\n        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n            trim = \"all\";\n        }\n\n        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n            trim = \"large\";\n        }\n\n        if (trim === false) {\n            trim = \"\";\n        }\n\n        var trimIncludes = function (item) {\n            return item.test(trim);\n        };\n\n        var rLarge = /large/;\n        var rSmall = /small/;\n        var rBoth = /both/;\n        var rMid = /mid/;\n        var rAll = /^all|[^sm]all/;\n        var rFinal = /final/;\n\n        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n        var trimMid = any([rMid, rAll], trimIncludes);\n        var trimFinal = any([rFinal, rAll], trimIncludes);\n\n        // Parse format string to create raw tokens array.\n        var rawTokens = map(template.match(tokenizer), function (token, index) {\n            var type = typeMap(token);\n\n            if (token.slice(0, 1) === \"*\") {\n                token = token.slice(1);\n\n                if (type !== \"escape\" && type !== \"general\") {\n                    stopTrim.push(type);\n                }\n            }\n\n            return {\n                index: index,\n                length: token.length,\n                text: \"\",\n\n                // Replace escaped tokens with the non-escaped token text.\n                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\n                // Ignore type on non-moment tokens.\n                type: ((type === \"escape\" || type === \"general\") ? null : type)\n            };\n        });\n\n        // Associate text tokens with moment tokens.\n        var currentToken = {\n            index: 0,\n            length: 0,\n            token: \"\",\n            text: \"\",\n            type: null\n        };\n\n        var tokens = [];\n\n        if (useLeftUnits) {\n            rawTokens.reverse();\n        }\n\n        each(rawTokens, function (token) {\n            if (token.type) {\n                if (currentToken.type || currentToken.text) {\n                    tokens.push(currentToken);\n                }\n\n                currentToken = token;\n\n                return;\n            }\n\n            if (useLeftUnits) {\n                currentToken.text = token.token + currentToken.text;\n            } else {\n                currentToken.text += token.token;\n            }\n        });\n\n        if (currentToken.type || currentToken.text) {\n            tokens.push(currentToken);\n        }\n\n        if (useLeftUnits) {\n            tokens.reverse();\n        }\n\n        // Find unique moment token types in the template in order of\n        // descending magnitude.\n        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n        // Exit early if there are no moment token types.\n        if (!momentTypes.length) {\n            return pluck(tokens, \"text\").join(\"\");\n        }\n\n        // Calculate values for each moment type in the template.\n        // For processing the settings, values are associated with moment types.\n        // Values will be assigned to tokens at the last step in order to\n        // assume nothing about frequency or order of tokens in the template.\n        momentTypes = map(momentTypes, function (momentType, index) {\n            // Is this the least-magnitude moment token found?\n            var isSmallest = ((index + 1) === momentTypes.length);\n\n            // Is this the greatest-magnitude moment token found?\n            var isLargest = (!index);\n\n            // Get the raw value in the current units.\n            var rawValue;\n\n            if (momentType === \"years\" || momentType === \"months\") {\n                rawValue = remainderMonths.as(momentType);\n            } else {\n                rawValue = remainder.as(momentType);\n            }\n\n            var wholeValue = Math.floor(rawValue);\n            var decimalValue = rawValue - wholeValue;\n\n            var token = find(tokens, function (token) {\n                return momentType === token.type;\n            });\n\n            if (isLargest && maxValue && rawValue > maxValue) {\n                isMaxValue = true;\n            }\n\n            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n                isMinValue = true;\n            }\n\n            // Note the length of the largest-magnitude moment token:\n            // if it is greater than one and forceLength is not set,\n            // then default forceLength to `true`.\n            //\n            // Rationale is this: If the template is \"h:mm:ss\" and the\n            // moment value is 5 minutes, the user-friendly output is\n            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n            // even though it has length of two if the template is \"h:mm:ss\";\n            //\n            // If the minutes output should always include the leading zero\n            // even when the hour is trimmed then set `{ forceLength: true }`\n            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n            // clearly wanted everything padded so we should output \"05:00\";\n            //\n            // If the user wants the full padded output, they can use\n            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n            // \"00:05:00\".\n            if (isLargest && forceLength === null && token.length > 1) {\n                forceLength = true;\n            }\n\n            // Update remainder.\n            remainder.subtract(wholeValue, momentType);\n            remainderMonths.subtract(wholeValue, momentType);\n\n            return {\n                rawValue: rawValue,\n                wholeValue: wholeValue,\n                // Decimal value is only retained for the least-magnitude\n                // moment type in the format template.\n                decimalValue: isSmallest ? decimalValue : 0,\n                isSmallest: isSmallest,\n                isLargest: isLargest,\n                type: momentType,\n                // Tokens can appear multiple times in a template string,\n                // but all instances must share the same length.\n                tokenLength: token.length\n            };\n        });\n\n        var truncMethod = trunc ? Math.floor : Math.round;\n        var truncate = function (value, places) {\n            var factor = Math.pow(10, places);\n            return truncMethod(value * factor) / factor;\n        };\n\n        var foundFirst = false;\n        var bubbled = false;\n\n        var formatValue = function (momentType, index) {\n            var formatOptions = {\n                useGrouping: useGrouping,\n                groupingSeparator: groupingSeparator,\n                decimalSeparator: decimalSeparator,\n                grouping: grouping,\n                useToLocaleString: useToLocaleString\n            };\n\n            if (useSignificantDigits) {\n                if (significantDigits <= 0) {\n                    momentType.rawValue = 0;\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                } else {\n                    formatOptions.maximumSignificantDigits = significantDigits;\n                    momentType.significantDigits = significantDigits;\n                }\n            }\n\n            if (isMaxValue && !bubbled) {\n                if (momentType.isLargest) {\n                    momentType.wholeValue = maxValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (isMinValue && !bubbled) {\n                if (momentType.isSmallest) {\n                    momentType.wholeValue = minValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n                // Apply precision to least significant token value.\n                if (precision < 0) {\n                    momentType.value = truncate(momentType.wholeValue, precision);\n                } else if (precision === 0) {\n                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n                } else { // precision > 0\n                    if (useSignificantDigits) {\n                        if (trunc) {\n                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n                        } else {\n                            momentType.value = momentType.rawValue;\n                        }\n\n                        if (momentType.wholeValue) {\n                            significantDigits -= momentType.wholeValue.toString().length;\n                        }\n                    } else {\n                        formatOptions.fractionDigits = precision;\n\n                        if (trunc) {\n                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n                        } else {\n                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n                        }\n                    }\n                }\n            } else {\n                if (useSignificantDigits && momentType.wholeValue) {\n                    // Outer Math.round required here to handle floating point errors.\n                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\n                    significantDigits -= momentType.wholeValue.toString().length;\n                } else {\n                    momentType.value = momentType.wholeValue;\n                }\n            }\n\n            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n                    delete formatOptions.maximumSignificantDigits;\n                }\n            }\n\n            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                foundFirst = true;\n            }\n\n            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\n            formatOptions.useGrouping = false;\n            formatOptions.decimalSeparator = \".\";\n            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n                momentType.formattedValueMS = formatNumber(momentType.value, {\n                    minimumIntegerDigits: 3,\n                    useGrouping: false\n                }, \"en\").slice(0, 2);\n            }\n\n            return momentType;\n        };\n\n        // Calculate formatted values.\n        momentTypes = map(momentTypes, formatValue);\n        momentTypes = compact(momentTypes);\n\n        // Bubble rounded values.\n        if (momentTypes.length > 1) {\n            var findType = function (type) {\n                return find(momentTypes, function (momentType) {\n                    return momentType.type === type;\n                });\n            };\n\n            var bubbleTypes = function (bubble) {\n                var bubbleMomentType = findType(bubble.type);\n\n                if (!bubbleMomentType) {\n                    return;\n                }\n\n                each(bubble.targets, function (target) {\n                    var targetMomentType = findType(target.type);\n\n                    if (!targetMomentType) {\n                        return;\n                    }\n\n                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n                        bubbleMomentType.rawValue = 0;\n                        bubbleMomentType.wholeValue = 0;\n                        bubbleMomentType.decimalValue = 0;\n                        targetMomentType.rawValue += 1;\n                        targetMomentType.wholeValue += 1;\n                        targetMomentType.decimalValue = 0;\n                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n                        bubbled = true;\n                    }\n                });\n            };\n\n            each(bubbles, bubbleTypes);\n        }\n\n        // Recalculate formatted values.\n        if (bubbled) {\n            foundFirst = false;\n            significantDigits = significantDigitsCache;\n            momentTypes = map(momentTypes, formatValue);\n            momentTypes = compact(momentTypes);\n        }\n\n        if (outputTypes && !(isMaxValue && !settings.trim)) {\n            momentTypes = map(momentTypes, function (momentType) {\n                if (find(outputTypes, function (outputType) {\n                    return momentType.type === outputType;\n                })) {\n                    return momentType;\n                }\n\n                return null;\n            });\n\n            momentTypes = compact(momentTypes);\n        } else {\n            // Trim Large.\n            if (trimLarge) {\n                momentTypes = rest(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - the smallest moment type\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n                });\n            }\n\n            // Largest.\n            if (largest && momentTypes.length) {\n                momentTypes = momentTypes.slice(0, largest);\n            }\n\n            // Trim Small.\n            if (trimSmall && momentTypes.length > 1) {\n                momentTypes = initial(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    // - the largest momentType\n                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n                });\n            }\n\n            // Trim Mid.\n            if (trimMid) {\n                momentTypes = map(momentTypes, function (momentType, index) {\n                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n                        return null;\n                    }\n\n                    return momentType;\n                });\n\n                momentTypes = compact(momentTypes);\n            }\n\n            // Trim Final.\n            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n                momentTypes = [];\n            }\n        }\n\n        if (returnMomentTypes) {\n            return momentTypes;\n        }\n\n        // Localize and pluralize unit labels.\n        each(tokens, function (token) {\n            var key = momentTokens[token.type];\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!key || !momentType) {\n                return;\n            }\n\n            var values = momentType.formattedValueEn.split(\".\");\n\n            values[0] = parseInt(values[0], 10);\n\n            if (values[1]) {\n                values[1] = parseFloat(\"0.\" + values[1], 10);\n            } else {\n                values[1] = null;\n            }\n\n            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\n            var labels = durationGetLabels(key, localeData);\n\n            var autoLocalized = false;\n\n            var pluralizedLabels = {};\n\n            // Auto-Localized unit labels.\n            each(localeData._durationLabelTypes, function (labelType) {\n                var label = find(labels, function (label) {\n                    return label.type === labelType.type && label.key === pluralKey;\n                });\n\n                if (label) {\n                    pluralizedLabels[label.type] = label.label;\n\n                    if (stringIncludes(token.text, labelType.string)) {\n                        token.text = token.text.replace(labelType.string, label.label);\n                        autoLocalized = true;\n                    }\n                }\n            });\n\n            // Auto-pluralized unit labels.\n            if (usePlural && !autoLocalized) {\n                labels.sort(durationLabelCompare);\n\n                each(labels, function (label) {\n                    if (pluralizedLabels[label.type] === label.label) {\n                        if (stringIncludes(token.text, label.label)) {\n                            // Stop checking this token if its label is already\n                            // correctly pluralized.\n                            return false;\n                        }\n\n                        // Skip this label if it is correct, but not present in\n                        // the token's text.\n                        return;\n                    }\n\n                    if (stringIncludes(token.text, label.label)) {\n                        // Replece this token's label and stop checking.\n                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n                        return false;\n                    }\n                });\n            }\n        });\n\n        // Build ouptut.\n        tokens = map(tokens, function (token) {\n            if (!token.type) {\n                return token.text;\n            }\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!momentType) {\n                return \"\";\n            }\n\n            var out = \"\";\n\n            if (useLeftUnits) {\n                out += token.text;\n            }\n\n            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n                out += \"< \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n                out += \"> \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                out += \"-\";\n                isNegative = false;\n            }\n\n            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n                out += momentType.formattedValueMS;\n            } else {\n                out += momentType.formattedValue;\n            }\n\n            if (!useLeftUnits) {\n                out += token.text;\n            }\n\n            return out;\n        });\n\n        // Trim leading and trailing comma, space, colon, and dot.\n        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n    }\n\n    // defaultFormatTemplate\n    function defaultFormatTemplate() {\n        var dur = this.duration;\n\n        var findType = function findType(type) {\n            return dur._data[type];\n        };\n\n        var firstType = find(this.types, findType);\n\n        var lastType = findLast(this.types, findType);\n\n        // Default template strings for each duration dimension type.\n        switch (firstType) {\n            case \"milliseconds\":\n                return \"S __\";\n            case \"seconds\": // Fallthrough.\n            case \"minutes\":\n                return \"*_MS_\";\n            case \"hours\":\n                return \"_HMS_\";\n            case \"days\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"d __\";\n                }\n            case \"weeks\":\n                if (firstType === lastType) {\n                    return \"w __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"w __, d __, h __\";\n            case \"months\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"M __\";\n                }\n            case \"years\":\n                if (firstType === lastType) {\n                    return \"y __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, M __, d __\";\n            default:\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, d __, h __, m __, s __\";\n        }\n    }\n\n    // init\n    function init(context) {\n        if (!context) {\n            throw \"Moment Duration Format init cannot find moment instance.\";\n        }\n\n        context.duration.format = durationsFormat;\n        context.duration.fn.format = durationFormat;\n\n        context.duration.fn.format.defaults = {\n            // Many options are defaulted to `null` to distinguish between\n            // 'not set' and 'set to `false`'\n\n            // trim\n            // Can be a string, a delimited list of strings, an array of strings,\n            // or a boolean.\n            // \"large\" - will trim largest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"small\" - will trim smallest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"both\" - will execute \"large\" trim then \"small\" trim.\n            // \"mid\" - will trim any zero-value tokens that are not the first or\n            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n            // e.g. \"large mid\" or \"both mid\".\n            // \"final\" - will trim the final token if it is zero-value. Use this\n            // option with \"large\" or \"both\" to output an empty string when\n            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n            // `false` - template tokens are not trimmed.\n            // `true` - treated as \"large\".\n            // `null` - treated as \"large\".\n            trim: null,\n\n            // stopTrim\n            // A moment token string, a delimited set of moment token strings,\n            // or an array of moment token strings. Trimming will stop when a token\n            // listed in this option is reached. A \"*\" character in the format\n            // template string will also mark a moment token as stopTrim.\n            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n            stopTrim: null,\n\n            // largest\n            // Set to a positive integer to output only the \"n\" largest-magnitude\n            // moment tokens that have a value. All lesser-magnitude moment tokens\n            // will be ignored. This option takes effect even if `trim` is set\n            // to `false`.\n            largest: null,\n\n            // maxValue\n            // Use `maxValue` to render generalized output for large duration values,\n            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n            /// applied to the greatest-magnitude moment token in the format template.\n            maxValue: null,\n\n            // minValue\n            // Use `minValue` to render generalized output for small duration values,\n            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n            // applied to the least-magnitude moment token in the format template.\n            minValue: null,\n\n            // precision\n            // If a positive integer, number of decimal fraction digits to render.\n            // If a negative integer, number of integer place digits to truncate to 0.\n            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n            // integer, sets the maximum number of significant digits used in the\n            // formatted output.\n            precision: 0,\n\n            // trunc\n            // Default behavior rounds final token value. Set to `true` to\n            // truncate final token value, which was the default behavior in\n            // version 1 of this plugin.\n            trunc: false,\n\n            // forceLength\n            // Force first moment token with a value to render at full length\n            // even when template is trimmed and first moment token has length of 1.\n            forceLength: null,\n\n            // userLocale\n            // Formatted numerical output is rendered using `toLocaleString`\n            // and the locale of the user's environment. Set this option to render\n            // numerical output using a different locale. Unit names are rendered\n            // and detected using the locale set in moment.js, which can be different\n            // from the locale of user's environment.\n            userLocale: null,\n\n            // usePlural\n            // Will automatically singularize or pluralize unit names when they\n            // appear in the text associated with each moment token. Standard and\n            // short unit labels are singularized and pluralized, based on locale.\n            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n            // renders a plural label for a value with decimal precision.\n            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n            // Label types and pluralization function are configurable in the\n            // localeData extensions.\n            usePlural: true,\n\n            // useLeftUnits\n            // The text to the right of each moment token in a format string\n            // is treated as that token's units for the purposes of trimming,\n            // singularizing, and auto-localizing.\n            // e.g. \"h [hours], m [minutes], s [seconds]\".\n            // To properly singularize or localize a format string such as\n            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n            // to the left of each moment token, set useLeftUnits to `true`.\n            // This plugin is not tested in the context of rtl text.\n            useLeftUnits: false,\n\n            // useGrouping\n            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useGrouping: true,\n\n            // useSignificantDigits\n            // Treat the `precision` option as the maximum significant digits\n            // to be rendered. Precision must be a positive integer. Significant\n            // digits extend across unit types,\n            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useSignificantDigits: false,\n\n            // template\n            // The template string used to format the duration. May be a function\n            // or a string. Template functions are executed with the `this` binding\n            // of the settings object so that template strings may be dynamically\n            // generated based on the duration object (accessible via `this.duration`)\n            // or any of the other settings. Leading and trailing space, comma,\n            // period, and colon characters are trimmed from the resulting string.\n            template: defaultFormatTemplate,\n\n            // useToLocaleString\n            // Set this option to `false` to ignore the `toLocaleString` feature\n            // test and force the use of the `formatNumber` fallback function\n            // included in this plugin.\n            useToLocaleString: true,\n\n            // formatNumber fallback options.\n            // When `toLocaleString` is detected and passes the feature test, the\n            // following options will have no effect: `toLocaleString` will be used\n            // for formatting and the grouping separator, decimal separator, and\n            // integer digit grouping will be determined by the user locale.\n\n            // groupingSeparator\n            // The integer digit grouping separator used when using the fallback\n            // formatNumber function.\n            groupingSeparator: \",\",\n\n            // decimalSeparator\n            // The decimal separator used when using the fallback formatNumber\n            // function.\n            decimalSeparator: \".\",\n\n            // grouping\n            // The integer digit grouping used when using the fallback formatNumber\n            // function. Must be an array. The default value of `[3]` gives the\n            // standard 3-digit thousand/million/billion digit groupings for the\n            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n            grouping: [3]\n        };\n\n        context.updateLocale('en', engLocale);\n    }\n\n    // Run feature tests for `Number#toLocaleString`.\n    var toLocaleStringFormatter = function(number, locale, options) {\n        return number.toLocaleString(locale, options);\n    };\n\n    toLocaleStringWorks = toLocaleStringSupportsLocales() && featureTestFormatter(toLocaleStringFormatter);\n    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestFormatterRounding(toLocaleStringFormatter);\n\n    // Run feature tests for `Intl.NumberFormat#format`.\n    var intlNumberFormatFormatter = function(number, locale, options) {\n        if (typeof window !== 'undefined' && window && window.Intl && window.Intl.NumberFormat) {\n            return window.Intl.NumberFormat(locale, options).format(number);\n        }\n    };\n\n    intlNumberFormatWorks = featureTestFormatter(intlNumberFormatFormatter);\n    intlNumberFormatRoundingWorks = intlNumberFormatWorks && featureTestFormatterRounding(intlNumberFormatFormatter);\n\n    // Initialize duration format on the global moment instance.\n    init(moment);\n\n    // Return the init function so that duration format can be\n    // initialized on other moment instances.\n    return init;\n});\n"]},"metadata":{},"sourceType":"script"}